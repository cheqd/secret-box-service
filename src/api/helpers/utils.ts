import Long from 'long'
import { Int53 } from '@cosmjs/math'
import { makeSignBytes } from '@cosmjs/proto-signing'
import { Secp256k1, Secp256k1Signature, sha256 } from '@cosmjs/crypto'
import { LumRegistry } from './registry'
import { AuthInfo } from './tx'
import { publicKeyToProto } from './keys'
import { Doc, SignMode, SignDoc, DocSigner, Fee } from '../types'
import { verify } from 'tiny-secp256k1';

/**
 * Generate transaction auth info payload
 *
 * @param docSigners Document signers
 * @param fee requested fee
 * @param signMode signing mode
 */
export const generateAuthInfoBytes = (docSigners: DocSigner[], fee: Fee, signMode: SignMode): Uint8Array => {
	const authInfo = {
		signerInfos: docSigners.map((signer: DocSigner) => ({
			publicKey: publicKeyToProto(signer.publicKey),
			modeInfo: {
				single: { mode: signMode },
			},
			sequence: Long.fromNumber(signer.sequence),
		})),
		fee: {
			amount: [...fee.amount],
			gasLimit: Long.fromNumber(Int53.fromString(fee.gas).toNumber()),
		},
	};
	return AuthInfo.encode(AuthInfo.fromPartial(authInfo)).finish();
};
/**
 * Generate transaction doc to be signed
 *
 * @param doc document to create the sign version
 * @param signerIdx index of the signer in the signers field used to specify the accountNumber for signature purpose
 * @param signMode signing mode for the transaction
 */
export const generateSignDoc = (doc: Doc, signerIdx: number, signMode: SignMode): SignDoc => {
	if (signerIdx < 0 || signerIdx > doc.signers.length) {
		throw new Error('Invalid doc signer index');
	}
	const txBody = {
		messages: doc.messages,
		memo: doc.memo,
	};
	const bodyBytes = LumRegistry.encode({
		typeUrl: '/cosmos.tx.v1beta1.TxBody',
		value: txBody,
	});

	return {
		bodyBytes,
		authInfoBytes: generateAuthInfoBytes(doc.signers, doc.fee, signMode),
		chainId: doc.chainId,
		accountNumber: Long.fromNumber(doc.signers[signerIdx].accountNumber),
	};
};

/**
 * Generate transaction sign doc bytes used to sign the transaction
 *
 * @param signDoc sign doc (as generated by the generateSignDoc function)
 */
export const generateSignDocBytes = (signDoc: SignDoc): Uint8Array => {
	return makeSignBytes(signDoc);
};

/**
 * Verify that a signature is valid
 *
 * @param signature signature (as generated by the generateSignature function)
 * @param signedBytes signed bytes (as generated by the generateSignDocBytes function or by the signMessage function)
 * @param publicKey public key of the signing key pair (secp256k1)
 */
export const verifySignature = async (signature: Uint8Array, signedBytes: Uint8Array, publicKey: Uint8Array): Promise<boolean> => {
	// const valid = await Secp256k1.verifySignature(Secp256k1Signature.fromFixedLength(signature), sha256(signedBytes), publicKey);
	// return valid;
	//
	const valid = verify(sha256(signedBytes), publicKey, signature)
	return valid;
};
